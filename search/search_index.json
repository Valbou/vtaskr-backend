{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"vTaskr Backend Documentation (Dev Doc) vTaskr is a to do list application for personnal use. The project is under active developpement, but not ready for production. Some breaking changes may appear without warning. You are visiting the backend developer documentation . Code repository available here: vTaskr Backend . If you are looking for frontend go to vTaskr Frontend . vTaskr Backend use CPython 3.12+, Flask and Gunicorn. Databases needed: Postgres 16+, Redis 6+. To See more details about dependencies, you can read pyproject.toml file. New to vTaskr To install vTaskr on premise: Getting Started . Roadmap The roadmap is actually not totally fixed. It moves depending on early adopters feedbacks and dev constraints. But you can see the main direction here .","title":"Home"},{"location":"#vtaskr-backend-documentation-dev-doc","text":"vTaskr is a to do list application for personnal use. The project is under active developpement, but not ready for production. Some breaking changes may appear without warning. You are visiting the backend developer documentation . Code repository available here: vTaskr Backend . If you are looking for frontend go to vTaskr Frontend . vTaskr Backend use CPython 3.12+, Flask and Gunicorn. Databases needed: Postgres 16+, Redis 6+. To See more details about dependencies, you can read pyproject.toml file.","title":"vTaskr Backend Documentation (Dev Doc)"},{"location":"#new-to-vtaskr","text":"To install vTaskr on premise: Getting Started .","title":"New to vTaskr"},{"location":"#roadmap","text":"The roadmap is actually not totally fixed. It moves depending on early adopters feedbacks and dev constraints. But you can see the main direction here .","title":"Roadmap"},{"location":"about/","text":"About vTaskr vTaskr is initially a simple personal python project to replace a 15 years old PHP private project manager. It's a good opportunity to use best development practices like: Hexagonal Architecture, modularity, clean code, test coverage etc... And it's a good opportunity to make it open source. I aim to keep this project stable and reactive to stay efficient in use. The backend part is not just a REST API, it's the core providing services. It can be used via API, CLI, Email, Telegram etc... Maintainers The only maintainer at this stage is me: Valentin BOUVAREL alias Valbou. The project is developed (too slowly) during my personal time. If you want to contribute, you can help me in some ways: giving feedback creating code writing tests writing translations filling out documentation etc... Contact me at contact@valbou.fr (EN, ES or FR).","title":"About"},{"location":"about/#about-vtaskr","text":"vTaskr is initially a simple personal python project to replace a 15 years old PHP private project manager. It's a good opportunity to use best development practices like: Hexagonal Architecture, modularity, clean code, test coverage etc... And it's a good opportunity to make it open source. I aim to keep this project stable and reactive to stay efficient in use. The backend part is not just a REST API, it's the core providing services. It can be used via API, CLI, Email, Telegram etc...","title":"About vTaskr"},{"location":"about/#maintainers","text":"The only maintainer at this stage is me: Valentin BOUVAREL alias Valbou. The project is developed (too slowly) during my personal time. If you want to contribute, you can help me in some ways: giving feedback creating code writing tests writing translations filling out documentation etc... Contact me at contact@valbou.fr (EN, ES or FR).","title":"Maintainers"},{"location":"getting-started/","text":"Get Started Get Started Install vTaskr Install dependencies Install translations Run migrations To run flask Install dev dependencies To run tests To see coverage To build the documentation Project global informations To use your own frontend To use your own mobile app Projects using vTaskr Install vTaskr No specific skill needed, but we need first to: - Install Postgres 16 or higher - Install Redis 6 or higher - Install Python 3.12 or higher - Create a python virtual environment (venv). apt install postgresql lsb-release redis apt install git python3-venv python3-pip python3 -m venv vtaskr-project cd vtaskr-project git clone git@github.com:Valbou/vtaskr-backend.git cd vtaskr-backend You may need to create a postgres user and a database. Config your own .env file (based on template.env file in project folder). Please change the default SECRET_KEY if you are using sessions. Install dependencies pip install . or to contribute pip install -e . Install translations chmod +x trad_* ./trad_compile_mo.sh users Run migrations alembic upgrade head To run flask # With Werkzeug (dev :5000) flask --app src.flask run # With Gunicorn (prod :8000) gunicorn src.flask:app vTaskr is now usable via CLI or API ! If you need help, create a Github issue. Install dev dependencies pip install .[dev] To run tests python -m coverage run -m unittest -vv To see coverage python -m coverage report To build the documentation To build a local documentation python -m mkdocs build To build and deploy github page documentation python -m mkdocs gh-deploy --theme mkdocs You can also use helpers respectively: ./build_doc.sh ./build_doc.sh deploy Project global informations The global project organisation is available in repository and apps structure The project respect some basic rules , please read them before submitting a merge request. To use your own frontend If you want to use your own frontend, you can see the OpenAPI documentation . ( Public Postman ) To use your own mobile app Actually no webapp or market specific application is planned. You can develop your own using backend API. Projects using vTaskr If you create one (frontend, backend, app...), let me a message with a link to your project. A list of apps using vTaskr backend will be referenced below.","title":"Getting Started"},{"location":"getting-started/#get-started","text":"Get Started Install vTaskr Install dependencies Install translations Run migrations To run flask Install dev dependencies To run tests To see coverage To build the documentation Project global informations To use your own frontend To use your own mobile app Projects using vTaskr","title":"Get Started"},{"location":"getting-started/#install-vtaskr","text":"No specific skill needed, but we need first to: - Install Postgres 16 or higher - Install Redis 6 or higher - Install Python 3.12 or higher - Create a python virtual environment (venv). apt install postgresql lsb-release redis apt install git python3-venv python3-pip python3 -m venv vtaskr-project cd vtaskr-project git clone git@github.com:Valbou/vtaskr-backend.git cd vtaskr-backend You may need to create a postgres user and a database. Config your own .env file (based on template.env file in project folder). Please change the default SECRET_KEY if you are using sessions.","title":"Install vTaskr"},{"location":"getting-started/#install-dependencies","text":"pip install . or to contribute pip install -e .","title":"Install dependencies"},{"location":"getting-started/#install-translations","text":"chmod +x trad_* ./trad_compile_mo.sh users","title":"Install translations"},{"location":"getting-started/#run-migrations","text":"alembic upgrade head","title":"Run migrations"},{"location":"getting-started/#to-run-flask","text":"# With Werkzeug (dev :5000) flask --app src.flask run # With Gunicorn (prod :8000) gunicorn src.flask:app vTaskr is now usable via CLI or API ! If you need help, create a Github issue.","title":"To run flask"},{"location":"getting-started/#install-dev-dependencies","text":"pip install .[dev]","title":"Install dev dependencies"},{"location":"getting-started/#to-run-tests","text":"python -m coverage run -m unittest -vv","title":"To run tests"},{"location":"getting-started/#to-see-coverage","text":"python -m coverage report","title":"To see coverage"},{"location":"getting-started/#to-build-the-documentation","text":"To build a local documentation python -m mkdocs build To build and deploy github page documentation python -m mkdocs gh-deploy --theme mkdocs You can also use helpers respectively: ./build_doc.sh ./build_doc.sh deploy","title":"To build the documentation"},{"location":"getting-started/#project-global-informations","text":"The global project organisation is available in repository and apps structure The project respect some basic rules , please read them before submitting a merge request.","title":"Project global informations"},{"location":"getting-started/#to-use-your-own-frontend","text":"If you want to use your own frontend, you can see the OpenAPI documentation . ( Public Postman )","title":"To use your own frontend"},{"location":"getting-started/#to-use-your-own-mobile-app","text":"Actually no webapp or market specific application is planned. You can develop your own using backend API.","title":"To use your own mobile app"},{"location":"getting-started/#projects-using-vtaskr","text":"If you create one (frontend, backend, app...), let me a message with a link to your project. A list of apps using vTaskr backend will be referenced below.","title":"Projects using vTaskr"},{"location":"roadmap/","text":"vTaskr Backend - ROADMAP Welcome to the vTaskr Roadmap. Here you can find features we need to add to upgrade version number. As vTaskr is an non profit project without fulltime dev, no release date can be fournished. Go to v0.1.0 The first goal is to permit a basic use of a to do list. An heavy base is needed in term of rights/permissions. [x] User can register [x] User can change profile information [x] User can change securely email and password [x] User can login securely [x] User can manage tasks (create, read, update, delete) [x] User can manage tags (create, read, update, delete) [x] User can't access to tasks or tags not owned [x] User can filter tasks with some basics filters [x] Add an OpenApiv3 documentation [x] User can associate Task and Tags together [x] Add alembic migrations [x] Check code organisation [x] Add gunicorn [x] Start a frontend developpement in an other git repository [x] User can manage groups (create, read, update, delete and achieve) [x] User can manage roles (create, read, update, delete and achieve) [x] User can manage role types (create, read, update, delete and achieve) [x] User can manage rights (create, read, update, delete and achieve) [x] User can't access to tasks not owned by at least one of his groups [x] User can delete his account efficiently (cannot delete a user if user has admin role on 2 groups or more !) [x] Add filters on list endpoints (filter groups according to role or filter rights according to a group etc...) [ ] When paginated result is asked, provide some helpers like page max number or the number of items available. [x] User can't modify tasks without the required role [x] User can invite another in a non private group [x] User can invite another user in a group with a specific role [ ] Telegram bot integration [ ] Add a basic dev documentation [ ] Cron job to send today and tomorrow tasks Go to v0.2.0 Start v0.2.0 dev when frontend is ok with v0.1.0 [ ] Code events developments [ ] Create tasks in to do lists template [ ] Transform a template into a todolist [ ] Use triggers to auto apply a template [ ] Task reccurence [ ] Weekly/Daily email with tasks of the period [ ] Sub tasks [ ] Project task organisation [ ] Tasks status (blocking) that block parent task [ ] Tasks association, link another task (nonblocking link) [ ] Tasks assignation to a group member [ ] Reminders/Alerts - Telegram/Email [ ] Add .ics generator (iCalendar format) Go to v0.3.0 Start v0.3.0 dev when frontend is ok with v0.2.0 [ ] Add tasks from telegram [ ] Add tasks from .ics sent by email [ ] Add tasks from github/gitlab/forgejo [ ] Add Keycloak integration [ ] Add hooks for external integration More in the futur...","title":"vTaskr Backend - ROADMAP"},{"location":"roadmap/#vtaskr-backend-roadmap","text":"Welcome to the vTaskr Roadmap. Here you can find features we need to add to upgrade version number. As vTaskr is an non profit project without fulltime dev, no release date can be fournished.","title":"vTaskr Backend - ROADMAP"},{"location":"roadmap/#go-to-v010","text":"The first goal is to permit a basic use of a to do list. An heavy base is needed in term of rights/permissions. [x] User can register [x] User can change profile information [x] User can change securely email and password [x] User can login securely [x] User can manage tasks (create, read, update, delete) [x] User can manage tags (create, read, update, delete) [x] User can't access to tasks or tags not owned [x] User can filter tasks with some basics filters [x] Add an OpenApiv3 documentation [x] User can associate Task and Tags together [x] Add alembic migrations [x] Check code organisation [x] Add gunicorn [x] Start a frontend developpement in an other git repository [x] User can manage groups (create, read, update, delete and achieve) [x] User can manage roles (create, read, update, delete and achieve) [x] User can manage role types (create, read, update, delete and achieve) [x] User can manage rights (create, read, update, delete and achieve) [x] User can't access to tasks not owned by at least one of his groups [x] User can delete his account efficiently (cannot delete a user if user has admin role on 2 groups or more !) [x] Add filters on list endpoints (filter groups according to role or filter rights according to a group etc...) [ ] When paginated result is asked, provide some helpers like page max number or the number of items available. [x] User can't modify tasks without the required role [x] User can invite another in a non private group [x] User can invite another user in a group with a specific role [ ] Telegram bot integration [ ] Add a basic dev documentation [ ] Cron job to send today and tomorrow tasks","title":"Go to v0.1.0"},{"location":"roadmap/#go-to-v020","text":"Start v0.2.0 dev when frontend is ok with v0.1.0 [ ] Code events developments [ ] Create tasks in to do lists template [ ] Transform a template into a todolist [ ] Use triggers to auto apply a template [ ] Task reccurence [ ] Weekly/Daily email with tasks of the period [ ] Sub tasks [ ] Project task organisation [ ] Tasks status (blocking) that block parent task [ ] Tasks association, link another task (nonblocking link) [ ] Tasks assignation to a group member [ ] Reminders/Alerts - Telegram/Email [ ] Add .ics generator (iCalendar format)","title":"Go to v0.2.0"},{"location":"roadmap/#go-to-v030","text":"Start v0.3.0 dev when frontend is ok with v0.2.0 [ ] Add tasks from telegram [ ] Add tasks from .ics sent by email [ ] Add tasks from github/gitlab/forgejo [ ] Add Keycloak integration [ ] Add hooks for external integration More in the futur...","title":"Go to v0.3.0"},{"location":"global/","text":"The project vTaskr vTaskr is a project to provide features to manage time and free your mind. This is possible if it's easy to use it. So productivity and efficiency are mandatory to keep using it. It's the primary focus ! To continue to develop vTaskr with pleasure, we need to keep base code clear, and clearly separate concerns. To contribute, please, keep this elements in mind. The project vTaskr Git Strategy Repository structure Apps structure Deep dive into apps: Git Strategy Master branch is not really clean (my fault), but I aim to tend to a cleaner history. One feature, one branch with squashed commits. After merge, branch is deleted. We are using a \"conventional commit\" like, to help to keep clear commits. A release is done after : all required features are done, documentation is up to date, translations are up to date, all unit tests passed, some manual end user tests are made, ideally at least a review is done. Repository structure At first level you can find: alembic : used to version database and track migrations. docs : used to provide this documentation with Mkdocs. hooks : some tools to help to be a good developer, and limit commits with bad PEP8 practicises before any CI. Need to be installed manually using shell command provided inside. src : vTaskr source code. tests : vTaskr tests (unit tests and integration tests). LICENSE : just to precise it's a GNU GPL v3 project. pyproject.toml : manage project dependencies and configs. README.md : to help users to find the doc \ud83d\ude07. run.sh : just a helper to run a dev HTTP server locally (if you need it). template.env : a .env template to keep up to date ! trad_*.hs : some helpers files to manage translation. Actually, the project is splitted in \"apps\" in the \"src\" sub directory: base : provide project global utilitaries (like a backend home page ). colors : provide elements to manage colors (but may disapear in a near futur to limit dependecies. Initially separated to limit duplicate code...). events : provide a basic internal event service to pass data cross apps. libs : provide external lib specific adapters. notifications : provide features to send informations to a user. ports : provide all bases classes to inherit from, for your adapters. static : provide some assets to insert in backend features like email or backend home page . tasks : provide elements to manage \"to do lists\", project management. users : provide elements to manage users authentication and authorizations. This app may be replaced by any Identity and Access Manager (IAM) like Keycloak. Excepting \"libs\", \"ports\", \"static\", all apps can be seen as a microservice, and could be separated in many dockers instances for scalability. Apps structure To help developers to find the right file in the good folder, we use an app structure like follow: events : this folder store observers and app events registry (to send and receive events from/to an other app). hmi : store files relative to Human Machine Interfaces, like HTML pages, API, CLI etc... and helpers like DTO etc... This views files may use dedicaded libs like Flask or FastAPI etc... and need a specific folder for each dependendy. managers : store files to manage models (use dependency injection to transparently store and retrieve data). models : core models for the app. No external lib dependency here (only python batteries included code). persistence : contain ports and adapters to access data storage (ORM, SQL/NoSQL, file system etc...). With a sub folder for each lib used (SQLAlchemy, Pewee, Pony...). services : store all services usable by a view. translations : to store... translations (.pot, .po and .mo files). flask_config.py : to setup some dedicaded config to flask. Feel free to create another file for another view lib respecting this pattern: mylib_config.py. settings.py : specific settings for the app, need at least a APP_NAME value. This code structure permit to move easily to a new lib with a limited rewrite scoped in the lib folder. We can imagine concurrent use of some libs in the same repo. Why not a Flask implementation and a FastAPI side by side, then you just need to run.sh --flask or run.sh --fastapi to swith ! Feel free to discuss about this code organisation if you have found a better way to do it ! Deep dive into apps: Users Tasks Notifications Events","title":"The project vTaskr"},{"location":"global/#the-project-vtaskr","text":"vTaskr is a project to provide features to manage time and free your mind. This is possible if it's easy to use it. So productivity and efficiency are mandatory to keep using it. It's the primary focus ! To continue to develop vTaskr with pleasure, we need to keep base code clear, and clearly separate concerns. To contribute, please, keep this elements in mind. The project vTaskr Git Strategy Repository structure Apps structure Deep dive into apps:","title":"The project vTaskr"},{"location":"global/#git-strategy","text":"Master branch is not really clean (my fault), but I aim to tend to a cleaner history. One feature, one branch with squashed commits. After merge, branch is deleted. We are using a \"conventional commit\" like, to help to keep clear commits. A release is done after : all required features are done, documentation is up to date, translations are up to date, all unit tests passed, some manual end user tests are made, ideally at least a review is done.","title":"Git Strategy"},{"location":"global/#repository-structure","text":"At first level you can find: alembic : used to version database and track migrations. docs : used to provide this documentation with Mkdocs. hooks : some tools to help to be a good developer, and limit commits with bad PEP8 practicises before any CI. Need to be installed manually using shell command provided inside. src : vTaskr source code. tests : vTaskr tests (unit tests and integration tests). LICENSE : just to precise it's a GNU GPL v3 project. pyproject.toml : manage project dependencies and configs. README.md : to help users to find the doc \ud83d\ude07. run.sh : just a helper to run a dev HTTP server locally (if you need it). template.env : a .env template to keep up to date ! trad_*.hs : some helpers files to manage translation. Actually, the project is splitted in \"apps\" in the \"src\" sub directory: base : provide project global utilitaries (like a backend home page ). colors : provide elements to manage colors (but may disapear in a near futur to limit dependecies. Initially separated to limit duplicate code...). events : provide a basic internal event service to pass data cross apps. libs : provide external lib specific adapters. notifications : provide features to send informations to a user. ports : provide all bases classes to inherit from, for your adapters. static : provide some assets to insert in backend features like email or backend home page . tasks : provide elements to manage \"to do lists\", project management. users : provide elements to manage users authentication and authorizations. This app may be replaced by any Identity and Access Manager (IAM) like Keycloak. Excepting \"libs\", \"ports\", \"static\", all apps can be seen as a microservice, and could be separated in many dockers instances for scalability.","title":"Repository structure"},{"location":"global/#apps-structure","text":"To help developers to find the right file in the good folder, we use an app structure like follow: events : this folder store observers and app events registry (to send and receive events from/to an other app). hmi : store files relative to Human Machine Interfaces, like HTML pages, API, CLI etc... and helpers like DTO etc... This views files may use dedicaded libs like Flask or FastAPI etc... and need a specific folder for each dependendy. managers : store files to manage models (use dependency injection to transparently store and retrieve data). models : core models for the app. No external lib dependency here (only python batteries included code). persistence : contain ports and adapters to access data storage (ORM, SQL/NoSQL, file system etc...). With a sub folder for each lib used (SQLAlchemy, Pewee, Pony...). services : store all services usable by a view. translations : to store... translations (.pot, .po and .mo files). flask_config.py : to setup some dedicaded config to flask. Feel free to create another file for another view lib respecting this pattern: mylib_config.py. settings.py : specific settings for the app, need at least a APP_NAME value. This code structure permit to move easily to a new lib with a limited rewrite scoped in the lib folder. We can imagine concurrent use of some libs in the same repo. Why not a Flask implementation and a FastAPI side by side, then you just need to run.sh --flask or run.sh --fastapi to swith ! Feel free to discuss about this code organisation if you have found a better way to do it !","title":"Apps structure"},{"location":"global/#deep-dive-into-apps","text":"Users Tasks Notifications Events","title":"Deep dive into apps:"},{"location":"global/events/","text":"Events App Events app manage events. This app permit to keep history on some changes if necessary. In some cases, this permit to replay a process or revert it. The main usage is to permit apps to share informations between there bounded context. This is the most important app to allow others apps to evolve with a relative independence. Only event payload \"contract\" matter. Model Objects Details Event : Represent an event trasmitted by event bus. Entities Relationship Diagram --- title: Model Relationship --- erDiagram Event Model Behavior When an app emit an event using eventbus, an event object is created and stored in memory. When the eventbus context end, automatically all events are saved in database an events are sent to all subscribers. You can exclude an event from save, by adding a _save parameter in event data, with the value \"False\". This _save option, limits the impact of events in the database. Some events are not critical or are just a consequence of another event.","title":"Events App"},{"location":"global/events/#events-app","text":"Events app manage events. This app permit to keep history on some changes if necessary. In some cases, this permit to replay a process or revert it. The main usage is to permit apps to share informations between there bounded context. This is the most important app to allow others apps to evolve with a relative independence. Only event payload \"contract\" matter.","title":"Events App"},{"location":"global/events/#model-objects","text":"","title":"Model Objects"},{"location":"global/events/#details","text":"Event : Represent an event trasmitted by event bus.","title":"Details"},{"location":"global/events/#entities-relationship-diagram","text":"--- title: Model Relationship --- erDiagram Event","title":"Entities Relationship Diagram"},{"location":"global/events/#model-behavior","text":"When an app emit an event using eventbus, an event object is created and stored in memory. When the eventbus context end, automatically all events are saved in database an events are sent to all subscribers. You can exclude an event from save, by adding a _save parameter in event data, with the value \"False\". This _save option, limits the impact of events in the database. Some events are not critical or are just a consequence of another event.","title":"Model Behavior"},{"location":"global/notifications/","text":"Notifications App Notifications app send messages to users, in some ways (Email, Telegram...). Based on events with some specific observers. Model Objects Details Contact : Represent a person or a group (mailing list ou Telegram group) with only one contact information. Subscription : It's like a magazine subscription, a user can register a subscription on some events and receive notification via the medium of his/her choice. Entities Relationship Diagram --- title: Model Relationship --- erDiagram Contact }|--|{ Subscription: subscribe","title":"Notifications App"},{"location":"global/notifications/#notifications-app","text":"Notifications app send messages to users, in some ways (Email, Telegram...). Based on events with some specific observers.","title":"Notifications App"},{"location":"global/notifications/#model-objects","text":"","title":"Model Objects"},{"location":"global/notifications/#details","text":"Contact : Represent a person or a group (mailing list ou Telegram group) with only one contact information. Subscription : It's like a magazine subscription, a user can register a subscription on some events and receive notification via the medium of his/her choice.","title":"Details"},{"location":"global/notifications/#entities-relationship-diagram","text":"--- title: Model Relationship --- erDiagram Contact }|--|{ Subscription: subscribe","title":"Entities Relationship Diagram"},{"location":"global/tasks/","text":"Tasks App Tasks app is in charge of task management. Tasks ownership is depending on the tenant. We are using a tenant_id to refer to this entity, most of the time, it's a group ( see users app ). Model Objects Details Task : Represent a task to do. A task may need less to 24 hours to be done. If a task need more time to be done, the task should be splitted. Tag : It's a optionnal text you can associate with tasks to organise them. You can organise your tasks in many ways with tags : a tag can represent a status, a project, a priority and so on. Entities Relationship Diagram --- title: Model Relationship --- erDiagram Task }|--|{ Tags: has","title":"Tasks App"},{"location":"global/tasks/#tasks-app","text":"Tasks app is in charge of task management. Tasks ownership is depending on the tenant. We are using a tenant_id to refer to this entity, most of the time, it's a group ( see users app ).","title":"Tasks App"},{"location":"global/tasks/#model-objects","text":"","title":"Model Objects"},{"location":"global/tasks/#details","text":"Task : Represent a task to do. A task may need less to 24 hours to be done. If a task need more time to be done, the task should be splitted. Tag : It's a optionnal text you can associate with tasks to organise them. You can organise your tasks in many ways with tags : a tag can represent a status, a project, a priority and so on.","title":"Details"},{"location":"global/tasks/#entities-relationship-diagram","text":"--- title: Model Relationship --- erDiagram Task }|--|{ Tags: has","title":"Entities Relationship Diagram"},{"location":"global/users/","text":"Users App Users app is in charge of authentication and authorizations/permissions. This app use an RBAC approach (Role Based Access Control). Model Objects Details Following models may be directly managed by users: User : Represent a physical person. Group : Represent a group of users that want to work together. Right : For each entity in app, a user can have rights like: read, create, update, delete, execute or subscribe... RoleType : A roletype , is a preconfigured or a user configured combination of rights on some entities. Role : It's the link between group , users and roletype . A user can have as many roles as groups membership. Invitation : Is a demand for a user to join a group with a roletype . The user may be registered or not. This others models are indirectly created by users via some actions: RequestChange : Is created temporarily when a user want to change it's email or it's password. Token : Is created for each successful login attempt. Entities Relationship Diagram --- title: Model Relationship (RBAC) --- erDiagram Right }|--|| RoleType: has User }|--|{ Role: has Group }|--|{ Role: in RoleType }|--|{ Role: with User }o--o{ Token: has erDiagram User }|--o{ Invitation: from Group }|--o{ Invitation: join RoleType }|--o{ Invitation: with","title":"Users App"},{"location":"global/users/#users-app","text":"Users app is in charge of authentication and authorizations/permissions. This app use an RBAC approach (Role Based Access Control).","title":"Users App"},{"location":"global/users/#model-objects","text":"","title":"Model Objects"},{"location":"global/users/#details","text":"Following models may be directly managed by users: User : Represent a physical person. Group : Represent a group of users that want to work together. Right : For each entity in app, a user can have rights like: read, create, update, delete, execute or subscribe... RoleType : A roletype , is a preconfigured or a user configured combination of rights on some entities. Role : It's the link between group , users and roletype . A user can have as many roles as groups membership. Invitation : Is a demand for a user to join a group with a roletype . The user may be registered or not. This others models are indirectly created by users via some actions: RequestChange : Is created temporarily when a user want to change it's email or it's password. Token : Is created for each successful login attempt.","title":"Details"},{"location":"global/users/#entities-relationship-diagram","text":"--- title: Model Relationship (RBAC) --- erDiagram Right }|--|| RoleType: has User }|--|{ Role: has Group }|--|{ Role: in RoleType }|--|{ Role: with User }o--o{ Token: has erDiagram User }|--o{ Invitation: from Group }|--o{ Invitation: join RoleType }|--o{ Invitation: with","title":"Entities Relationship Diagram"}]}